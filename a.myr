use sys
use std

trait layer @a -> @b :: layer @a =
	get : (a : @a -> @b)
	put : (a : @a, p : @b -> void)
;;

trait alloc @t =
	alloc : (-> @t#)
	free  : (p : @t# -> void)
;;

type system(@s) = struct
	super : @s
	count : std.size
;;

impl layer system(@a) -> @b# =
	get = {a; std.put("this is system(void)::get\n"); -> std.alloc()}
	put = {a, p; -> std.free(p)}
;;

type fooheap(@s) = struct
	super : @s	
	count : std.size
;;

impl layer fooheap(@s) -> @b# =
	get = {a; a.count++; std.put("this is fooheap(system) get\n"); -> get(a.super)}
	put = {a, p; std.put("this is fooheap(system) put\n")}
;;

type foo = struct
	data : byte[:]
	len  : std.size
;;

impl alloc foo =
	alloc = {;-> get(m)}
	free  = {p; put(m, p)}
;;

var s : system(void)
var m : fooheap(system(void))

const main = {
	var x : int#
	var y : byte[20]#

	std.put("hello\n")


	x = get(s)
	x# = 123
	std.put("x@{}={}\n", x, x#)

	y = get(m)
	y#[0] = 100
	y#[1] = 200
	std.put("y@{}={}\n", y, y#)

	var p : foo# = alloc()
	p.data = "abc"
	std.put("p.data={}\n", p.data)
	free(p)

	var z = 1250
	std.put("s@{} m@{}\n", &s, &m)
	var f = {
		std.put("s@{} m@{} z@{}={}\n", &s, &m, &z, z)
		{; std.put("s@{} m@{} z@{}={}\n", &s, &m, &z, z)}()
	}
	f()

	sys.write(1, "abc\n")
}
